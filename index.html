<html>
    <head>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Anton:wght@400&display=swap" rel="stylesheet">
        <style>
            html {
                background-image: linear-gradient(to left, rgba(2,0,36,1), rgba(7,6,95,1), rgba(9,9,121,1));
                height: 100%;
            }

            body {
                color: white;
                font-family: 'Anton', sans-serif;
            }
            
            h1, h2, h3, h4 {
                margin: 0;
                padding: 0;
                font-family: 'Anton', sans-serif;
                border-bottom: 1px dashed turquoise;
            }

            .row {
                display: flex;
            }

            .col {
                padding: 1%;
                flex: 1 1 0;
            }

            .fit-col {
                padding: 1%;
                flex: 1 0 0;
            }

            .justified {
                display: flex;
                justify-content: center;
            }

            #computations, #results {
                height: 300px;
                overflow-y: auto;
            }

            #computations-container {
                border-left: 3px solid turquoise;
            }

            #computations-container {
                padding: 1%;
            }

            .result, .computation {
                cursor: pointer;
                padding: 4px;
                border-left: 4px solid turquoise;
                margin: 15px;
                width: fit-content;
            }

            .result:hover, .computation:hover {
                border-left: 0px;
                border-right: 4px solid turquoise;
            }

            .badge {
                border-radius: 5px;
                padding: 3px;
                color: white;
            }

            .true {
                background-color: green;
            }

            .false {
                background-color: red;
            }

            #compile {
                cursor: pointer;
                background-color: transparent;
                border: 3px solid turquoise;
                color: white;
                border-radius: 30px;
                font-size: 18px;
                font-family: 'Anton', sans-serif;
            }

            #compile:hover {
                background-color: turquoise;
                border: 3px solid transparent;
            }

            textarea {
                background-color: transparent;
                border: 3px solid turquoise;
                color: white;
                font-family: 'Anton', sans-serif;
            }

            textarea:focus {
                outline: transparent;
            }
        </style>
    </head>
    <body>
        <div class="row">
            <div class="col" style="background-color: black;">
                <div class="justified">
                    <textarea id="notebook" rows="25" cols="105"># Please use 'and', 'or', 'not' keywords as basic logic operators.&#13;&#13;x = 1&#13;y = 1&#13;z = 0&#13;m = 1&#13;v = ((x and y) or (x and z)) and m</textarea>
                </div>
            </div>
            <div class="col">
                <div id="settings" class="row">
                    <div class="col">
                        <h3>RESULTS</h3>
                    </div>
                    <div class="col">
                        <button id="compile" value="Compile" onclick="compile()">Compile</button>
                    </div>
                </div>
                <div class="row">
                    <div id="computations-container">
                        <h4>Solved Variables:</h4>
                        <div id="results"></div>
                    </div>
                    <div id="computations-container">
                        <h4>Computed expressions:</h4>
                        <div id="computations"></div>
                    </div>
                </div>
            </div>
        </div>
        <script>
            const notebook = document.getElementById("notebook");
            const definitions = {
                "true": true,
                "false": false,
                "0": false,
                "1": true,
            };

            const computations = {};

            compile();

            notebook.addEventListener('change', (event) => {
                compile();
                
            });

            function compile() {
                const expressions = notebook.value.split(/\r?\n/);
                for (let i = 0; i < expressions.length; i++) {
                    parse(expressions[i]);
                }
                console.log(definitions);
                console.log(computations);
                display();
            }

            function display() {
                let resultsHtml = "", computationsHtml = "";
                let names = Object.keys(definitions);
                for (let i = 0; i < names.length; i++) {
                    if (isDefaultDeclaration(names[i])) {
                        continue;
                    }

                    let value = definitions[names[i]];
                    resultsHtml += `<div class="result"><span class="definition">${names[i]}</span> equals <span class="badge ${value ? "true" : "false"}">${value}</span></div>`;
                }

                let expressions = Object.keys(computations);
                for (let i = 0; i < expressions.length; i++) {
                    let value = computations[expressions[i]];
                    computationsHtml += `<div class="computation"><span class="definition">${expressions[i]}</span> equals <span class="badge ${value ? "true" : "false"}">${value}</span></div>`;
                }

                document.getElementById("results").innerHTML = resultsHtml;
                document.getElementById("computations").innerHTML = computationsHtml;
            }

            function isDefaultDeclaration(name) {
                return name === "true" || name === "false" || name === "0" || name === "1";
            }

            function isVariable(term) {
                return !isExpression(term);
            }

            function isExpression(term) {
                return term.includes(" ");
            }

            function isComplexExpression(term) {
                return isExpression(term) && term.includes("(") && term.includes(")");
            }

            function isDeclaration(term) {
                return definitions[term] !== undefined;
            }

            function parse(expression) {
                expression = expression.trim();
                if (!expression || expression[0] === "#") {
                    // The expression is either empty or a comment - no evaluation needed for both.
                    return;
                }

                if (expression.includes("=")) {
                    let equationParts = expression.split("=");
                    let leftSide = equationParts[0].trim();
                    let rightSide = equationParts[1].trim();

                    if (isVariable(leftSide)) {
                        console.log(leftSide);
                        definitions[leftSide] = isComplexExpression(rightSide)
                            ? parseComplexExpression(rightSide)
                            : evaluate(rightSide);
                    }
                }
            }

            function parseComplexExpression(expression) {
                console.log(`Parse ${expression}`);
                const indexes = [];
                let evaluatedExpression = expression;
                for (let i = 0; i < expression.length; i++) {
                    if (expression[i] === '(') {
                        indexes.push(i);
                    } else if (expression[i] === ')') {
                        let start = indexes.pop() + 1;
                        let subexpression = expression.substring(start, i);
                        evaluatedExpression = evaluatedExpression.replace(`(${subexpression})`, isComplexExpression(subexpression) ? parseComplexExpression(subexpression) : evaluate(subexpression));
                    }
                }

                if (isComplexExpression(evaluatedExpression)) {
                    computations[expression] = parseComplexExpression(evaluatedExpression);
                    return parseComplexExpression(evaluatedExpression);
                }

                if (isExpression(evaluatedExpression)) {
                    computations[expression] = evaluate(evaluatedExpression);
                    return evaluate(evaluatedExpression);
                }

                if (isDeclaration(evaluatedExpression)) {
                    computations[expression] = definitions[evaluatedExpression];
                    return definitions[evaluatedExpression];
                }

                return evaluatedExpression;
            }

            function evaluate(expression) {
                if (isDeclaration(expression)) {
                    return definitions[expression];
                }

                if (expression[0] === "(" && expression[expression.length - 1] === ")") {
                    // Simple expression wrapped in unneeded parentesses, just remove them.
                    expression = expression.substring(1, expression.length - 1);
                }

                console.log(`Evaluate ${expression}`);

                let elements = expression.split(' ');

                let elementsWithoutNegation = [];
                for (let i = 0; i < elements.length; i++) {
                    if(elements[i] == "not") {
                        i = i + 1;
                        elementsWithoutNegation.push(!definitions[elements[i]]);
                    } else {
                        elementsWithoutNegation.push(elements[i]);
                    }
                }
                
                let lastEvaluated = definitions[elementsWithoutNegation[0]];
                for (let i = 1; i < elementsWithoutNegation.length; i += 2) {
                    console.log(`${elementsWithoutNegation[i + 1]} is ${definitions[elementsWithoutNegation[i + 1]]}`);
                    switch (elementsWithoutNegation[i]) {
                        case "and":
                            lastEvaluated = lastEvaluated && definitions[elementsWithoutNegation[i + 1]];
                            break;
                        case "or":
                            lastEvaluated = lastEvaluated || definitions[elementsWithoutNegation[i + 1]];
                            break;
                    }
                }

                computations[expression] = lastEvaluated;

                return lastEvaluated;
            }
        </script>
    </body>
</html>